import{_ as i,c as a,o as t,a9 as e}from"./chunks/framework.CKUMok-g.js";const c=JSON.parse('{"title":"博客构建性能优化笔记 | 提速 3 倍","description":"","frontmatter":{"head":[["script",{},"!function(p){\\"use strict\\";!function(t){var s=window,e=document,i=p,c=\\"\\".concat(\\"https:\\"===e.location.protocol?\\"https://\\":\\"http://\\",\\"sdk.51.la/js-sdk-pro.min.js\\"),n=e.createElement(\\"script\\"),r=e.getElementsByTagName(\\"script\\")[0];n.type=\\"text/javascript\\",n.setAttribute(\\"charset\\",\\"UTF-8\\"),n.async=!0,n.src=c,n.id=\\"LA_COLLECT\\",i.d=n;var o=function(){s.LA.ids.push(i)};s.LA?s.LA.ids&&o():(s.LA=p,s.LA.ids=[],o()),r.parentNode.insertBefore(n,r)}()}({\\"id\\":\\"Jgmg5avjAUvoyePS\\",\\"ck\\":\\"Jgmg5avjAUvoyePS\\",\\"hashMode\\":true});"]]},"headers":[],"relativePath":"essay/dev/2024-blog-build-perf.md","filePath":"essay/dev/2024-blog-build-perf.md","lastUpdated":1769849351000}'),n={name:"essay/dev/2024-blog-build-perf.md"};function l(h,s,p,k,r,d){return t(),a("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1769849351000"},[...s[0]||(s[0]=[e(`<h1 id="博客构建性能优化笔记-提速-3-倍" tabindex="-1">博客构建性能优化笔记 | 提速 3 倍 <a class="header-anchor" href="#博客构建性能优化笔记-提速-3-倍" aria-label="Permalink to “博客构建性能优化笔记 | 提速 3 倍”">​</a></h1><p>笔者的博客基于 VitePress 搭建的，使用其自定义主题能力完成博客主题 <a href="https://github.com/zhouxun0803/tree/master/packages/theme" target="_blank" rel="noreferrer">@sugarat/theme</a> 的搭建。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/cba8352b9fdd1e26dfe2146dde30bc97" alt="" loading="lazy"></p><p>前段时间有群友反馈说使用主题构建后耗时增加非常明显。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/5eb95eee23034a7cfb39d938fce52437" alt="" loading="lazy"></p><p>前后耗时大概增加了 10 倍，过于离谱了。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/1c870dbc78093fa15454d3d6d1c32dfe" alt="" loading="lazy"></p><p>断断续续的投入差不多 1 个月的时间完成了优化，效果还是很明显。</p><p>至此写篇文章记录&amp;分享一下优化过程。</p><h2 id="先看一下优化前后的效果" tabindex="-1">先看一下优化前后的效果 <a class="header-anchor" href="#先看一下优化前后的效果" aria-label="Permalink to “先看一下优化前后的效果”">​</a></h2><ul><li>测试项目：<a href="https://github.com/zhouxun0803/tree/master/packages/blogpress" target="_blank" rel="noreferrer">笔者的博客</a>，差不多 490 篇文章。</li><li>测试机器：Mac Mini (M1, 2020)</li></ul><h3 id="仅开启博客相关的样式能力" tabindex="-1">仅开启博客相关的样式能力 <a class="header-anchor" href="#仅开启博客相关的样式能力" aria-label="Permalink to “仅开启博客相关的样式能力”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">VitePress 默认主题</th><th style="text-align:center;">优化后主题</th><th style="text-align:center;">优化前主题</th></tr></thead><tbody><tr><td style="text-align:center;">16.38s</td><td style="text-align:center;">20.56s</td><td style="text-align:center;">32.36s</td></tr><tr><td style="text-align:center;"><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/20ccceb73d416e3341dab78e04ae3c7d" alt="" loading="lazy"></td><td style="text-align:center;"><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/d4752955e7fb980b79a655c9f7db3927" alt="" loading="lazy"></td><td style="text-align:center;"><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/978a478651b2186199eadcc732e1ae83" alt="" loading="lazy"></td></tr><tr><td style="text-align:center;">对比目标</td><td style="text-align:center;">+4.18s</td><td style="text-align:center;">+15.98s</td></tr></tbody></table><h3 id="开启拓展能力" tabindex="-1">开启拓展能力 <a class="header-anchor" href="#开启拓展能力" aria-label="Permalink to “开启拓展能力”">​</a></h3><p><a href="https://www.npmjs.com/package/vitepress-plugin-rss" target="_blank" rel="noreferrer">RSS</a>，<a href="https://www.npmjs.com/package/vitepress-plugin-pagefind" target="_blank" rel="noreferrer">pagefind 离线搜索</a></p><table tabindex="0"><thead><tr><th style="text-align:center;">优化后</th><th style="text-align:center;">优化后</th><th style="text-align:center;">优化前</th></tr></thead><tbody><tr><td style="text-align:center;">RSS不开启HTML生成 + 离线搜索</td><td style="text-align:center;">RSS + 离线搜索</td><td style="text-align:center;">RSS + 离线搜索</td></tr><tr><td style="text-align:center;">25.70s</td><td style="text-align:center;">30.93s</td><td style="text-align:center;">50.85s</td></tr><tr><td style="text-align:center;"><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/77a35411fbea3f64936abfcc6622e2c2" alt="" loading="lazy"></td><td style="text-align:center;"><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/2fff5a8446c1b8a22ebd603d1759cd18" alt="" loading="lazy"></td><td style="text-align:center;"><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/4fb36cd4141dbba944cf66d88228e8b6" alt="" loading="lazy"></td></tr><tr><td style="text-align:center;">+9.4s</td><td style="text-align:center;">+14.55s</td><td style="text-align:center;">+34.47s</td></tr></tbody></table><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to “小结”">​</a></h3><p>整体提速约 3 倍：</p><ul><li>只开启基础能力：额外耗时从 16s 缩短至 4s</li><li>拓展能力耗时：额外耗时从 34s 缩短到 10 s</li></ul><h2 id="问题定位" tabindex="-1">问题定位 <a class="header-anchor" href="#问题定位" aria-label="Permalink to “问题定位”">​</a></h2><p>先定位耗时的位置，再想办法进行优化。</p><p>我们可以直接用 <code>console.time</code> 和 <code>console.timeEnd</code> 打印出耗时信息。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;flag&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;flag&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 打印出耗时</span></span></code></pre></div><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/3bbe8436fb53bb0baca9fdc7e6eda240" alt="" loading="lazy"></p><p>主要关注有循环和外部调用的逻辑，在其前后加上打印耗时。</p><p>简单打了几个点，就有如下的结果咯 ⏰。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/4b9c8ea5149c417e65199050558d2614" alt="" loading="lazy"></p><p>在主题入口和两个插件都有一段类似的代码逻辑，读取文件内容构造 meta 信息。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/7a6dcb360c7410855b915f05fb16ccf7" alt="" loading="lazy"></p><h2 id="优化方式" tabindex="-1">优化方式 <a class="header-anchor" href="#优化方式" aria-label="Permalink to “优化方式”">​</a></h2><h3 id="异步操作文件" tabindex="-1">异步操作文件 <a class="header-anchor" href="#异步操作文件" aria-label="Permalink to “异步操作文件”">​</a></h3><p>读取文件内容用于提取 <code>frontmatter</code> 信息，生成描述，标题等内容，会用于首页渲染。</p><p>使用 <code>fs.promises</code> 异步操作文件，这样可以避免阻塞进程。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.promises.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filePath, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="异步创建子进程" tabindex="-1">异步创建子进程 <a class="header-anchor" href="#异步创建子进程" aria-label="Permalink to “异步创建子进程”">​</a></h3><p>主要通过调用 <code>git</code> 指令获取文件最后的修改时间，用于展示文章的最后的修改时间。</p><p>原来使用的 <code>spawnSync</code>，同样也是同步执行的方法。</p><p>使用 <code>spawn + Promise</code> 替换 <code>spawnSync</code>，避免阻塞进程。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawnSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;git&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;log&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;--pretty=&quot;%ci&quot;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, url])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;git&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;log&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;--pretty=&quot;%ai&quot;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, url])</span></span></code></pre></div><h3 id="使用缓存" tabindex="-1">使用缓存 <a class="header-anchor" href="#使用缓存" aria-label="Permalink to “使用缓存”">​</a></h3><p>在日志里可以发现，Vite 插件里 <code>load</code> 钩子在 vitepress build 时执行了2次。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/974ca3b77ceb5724138bba0a9918eae0" alt="" loading="lazy"></p><p>因此针对会重复执行的逻辑，可以添加添加一段缓存读写的逻辑，能明显降低二次执行相关逻辑的时间。</p><p>时间的获取使用 <code>Map</code> 缓存文件的日期信息，在文件路径不变的情况下复用上一次获取的内容</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cached</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cached) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cached</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="并发执行异步操作" tabindex="-1">并发执行异步操作 <a class="header-anchor" href="#并发执行异步操作" aria-label="Permalink to “并发执行异步操作”">​</a></h3><p>如果是 <code>await new promise</code> 在执行的时候才创建和获取 promise 结果，提升不是特别明显。</p><p>比如 <code>spawn</code> 创建子进程调用，配合 <code>await promise</code>，在文章数量较多时，依然会有明显的耗时。</p><p>所以可以将文件内容和 git 时间的获取动作提前且并发执行。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> contentPromises</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> files.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  prev[f] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contentPromise: fs.promises.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    datePromise: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getFileBirthTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, {})</span></span></code></pre></div><p>但在测试的时候发现这样写偶尔会执行出错或提升不明显，大概是并发的执行的 Promise 和 spawn 创建子进程过多的关系。</p><p>于是引入 <a href="https://www.npmjs.com/package/p-limit" target="_blank" rel="noreferrer">p-limit</a> 来控制并发的 promise 数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> os </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;node:os&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pLimit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;p-limit&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> limit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pLimit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P_LIMT_MAX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> os.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cpus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> metaPromise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> limit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getArticleMeta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>这里默认值使用<code>os.cpus().length</code>来获取 CPU 核心的数量，这样创建的子进程能充分利用上多核的能力，不然并行值调得再大，也不会有明显的提升。</p><h3 id="非必要第三方能力提供开关" tabindex="-1">非必要第三方能力提供开关 <a class="header-anchor" href="#非必要第三方能力提供开关" aria-label="Permalink to “非必要第三方能力提供开关”">​</a></h3><p>有些能力，可能没有用到，但是打开就是会增加额外的耗时，<strong>对文件做了不改变内容的分析与处理</strong>。</p><p>在测试中发现 RSS 生成 HTML 的逻辑非常耗时，文件内容越多，耗时越多。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(file, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createMarkdownRenderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vitepress&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mdRender</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMarkdownRenderer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> html</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mdRender.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileContent)</span></span></code></pre></div><p><code>vitepress</code> 内置使用的 <code>markdown-it</code> ，并且内置了许多的插件，html 作为 RSS 内容的组成也不是必要的部分，因此可以做成可选的能力，交由用户选择是否开启，同时将生成的方式也做成可配置的，用户可以传入更加精简的生成方法。</p><p>另一个是 markdown 图表的渲染，主题内置的 <a href="https://mermaid.nodejs.cn/" target="_blank" rel="noreferrer">mermaid</a> 相关插件，发现打开即使页面里没有使用，也会增加额外的耗时，且会增加非常的多。</p><p>因此将这个也弄成默认关闭，由用户自己选择是否开启，深度优化需要修改对应插件的源码，还没来得及研究这个计划后续再做。</p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/8ef3d9d54c4589808965322186e69426" alt="" loading="lazy"></p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to “最后”">​</a></h2><p>个人觉得代码应该还有优化空间，下来再探索一下，攒一波有重大突破再来分享分享。</p><p>博客本身的优化，之前也发文章分享过来，感兴趣的可以看看：<a href="./2024-blog-perf.html">博客性能优化笔记</a></p><p><img src="https://cdn.upyun.sugarat.top/mdImg/sugar/32ad0f558070d69b3f50bbcdc7a8c988" alt="" loading="lazy"></p><p>没错：已经拉满了！</p>`,67)])])}const E=i(n,[["render",l]]);export{c as __pageData,E as default};
