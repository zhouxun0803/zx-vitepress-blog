import{_ as a,c as i,o as e,a9 as r}from"./chunks/framework.CKUMok-g.js";const b=JSON.parse('{"title":"前端备战之操作系统","description":"","frontmatter":{"isTimeLine":true,"title":"前端备战之操作系统","date":"2020-10-23T00:00:00.000Z","tags":["面试经验"],"categories":["备战春秋"],"head":[["script",{},"!function(p){\\"use strict\\";!function(t){var s=window,e=document,i=p,c=\\"\\".concat(\\"https:\\"===e.location.protocol?\\"https://\\":\\"http://\\",\\"sdk.51.la/js-sdk-pro.min.js\\"),n=e.createElement(\\"script\\"),r=e.getElementsByTagName(\\"script\\")[0];n.type=\\"text/javascript\\",n.setAttribute(\\"charset\\",\\"UTF-8\\"),n.async=!0,n.src=c,n.id=\\"LA_COLLECT\\",i.d=n;var o=function(){s.LA.ids.push(i)};s.LA?s.LA.ids&&o():(s.LA=p,s.LA.ids=[],o()),r.parentNode.insertBefore(n,r)}()}({\\"id\\":\\"Jgmg5avjAUvoyePS\\",\\"ck\\":\\"Jgmg5avjAUvoyePS\\",\\"hashMode\\":true});"]]},"headers":[],"relativePath":"offer/experience/os.md","filePath":"offer/experience/os.md","lastUpdated":1769849351000}'),h={name:"offer/experience/os.md"};function n(t,l,d,o,s,c){return e(),i("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1603411200000"},[...l[0]||(l[0]=[r('<h1 id="前端备战之操作系统" tabindex="-1">前端备战之操作系统 <a class="header-anchor" href="#前端备战之操作系统" aria-label="Permalink to “前端备战之操作系统”">​</a></h1><center><p>内容根据<a href="./">春招面经</a>整理,文末有面试遇到的相关问题</p><p>笔者文笔有限,如有不足之处还请斧正</p></center><p><strong>文字内容较多,请细细品读,有些点可能有赘述之处,品完此文,面试与此相关的问题,就能得心应手的对付了,还能总结出一套自己的结论</strong></p><h2 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to “进程”">​</a></h2><blockquote><p>进程是一种抽象的概念，从来没有统一的标准定义</p></blockquote><h3 id="各式各样的定义" tabindex="-1">各式各样的定义 <a class="header-anchor" href="#各式各样的定义" aria-label="Permalink to “各式各样的定义”">​</a></h3><ul><li><code>进程是可并发执行的程序在一个数据集合上的运行过程</code></li><li><code>进程是指进程实体的运行过程</code></li><li>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程</li><li>操作系统进行资源分配和调度的一个独立单位</li><li>行为的一个规则叫做程序，程序在处理机上执行时所发生的活动称为进程</li><li>具有一定功能的程序在某个数据集合上的一次活动</li><li>进程是一个程序与其数据一道通过处理机的执行所发生的活动</li></ul><h3 id="两个基本属性" tabindex="-1">两个基本属性 <a class="header-anchor" href="#两个基本属性" aria-label="Permalink to “两个基本属性”">​</a></h3><ul><li>进程是一个资源分配的基本单位</li><li>进程是一个可独立调度和分派的基本单位</li></ul><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to “特点”">​</a></h3><ol><li>结构性:由程序(段),数据(段),进程控制块(PCB)三部分组成 <ul><li>程序：描述进程要完成的功能</li><li>数据：程序执行时所需数据和工作区</li><li>进程控制块：进程唯一标识，包含描述信息与控制信息 <ul><li>OS感知进程存在的唯一标志</li></ul></li></ul></li><li>动态性:进程是程序的执行过程 <ul><li>临时产生的，动态产生/消亡</li></ul></li><li>并发性:多个进程可同时存在于内存中,能在一段时间内同时运行</li><li>独立性:独立运行的基本单位,独立获得资源与调度的基本单位 <ul><li>进程是系统进行资源分配和调度的一个独立单位</li></ul></li><li>异步性:各自的进程独立的按不可预知的速度推进</li></ol><h3 id="状态" tabindex="-1">状态 <a class="header-anchor" href="#状态" aria-label="Permalink to “状态”">​</a></h3><p><img src="https://img.cdn.sugarat.top/mdImg/MTU4NDMyOTQ0ODQ1OA==584329448458" alt="" loading="lazy"></p><ul><li>运行(Running):占用CPU且正在CPU上运行</li><li>就绪(Ready):已具备运行条件(获取了除CPU以外的其它所需资源),但CPU没有空闲</li><li>等待/阻塞/睡眠(Waiting/Blocked):因等待某一事件而不能运行</li></ul><h3 id="低级调度" tabindex="-1">低级调度 <a class="header-anchor" href="#低级调度" aria-label="Permalink to “低级调度”">​</a></h3><blockquote><p>低级调度又称为<code>进程调度</code>、微观调度或短程调度</p></blockquote><ul><li>非抢占式调度:不允许某进程抢占已经分配出去的处理机。</li><li>抢占式调度:允许调度程序根据某种原则，暂停正在执行的进程，将处理*机重新分配给另一进程。 <ul><li>抢占原则 <ul><li>优先权原则</li><li>短作业（进程）优先原则</li><li>时间片原则</li></ul></li></ul></li></ul><h3 id="进程调度时机" tabindex="-1">进程调度时机 <a class="header-anchor" href="#进程调度时机" aria-label="Permalink to “进程调度时机”">​</a></h3><ul><li>一个进程运行完毕，或因某种错误而终止运行</li><li>当一个进程在运行时变为等待状态（等待I/O）</li><li>分时系统中时间片到</li><li>当有一个优先级更高的进程就绪（抢占式）</li><li>在进程通信中，执行中的进程执行了某种原语操作（P操作，阻塞原语）</li></ul><h3 id="cpu调度过程" tabindex="-1">CPU调度过程 <a class="header-anchor" href="#cpu调度过程" aria-label="Permalink to “CPU调度过程”">​</a></h3><p>即进程<strong>切换步骤</strong></p><p>为了控制进程的执行，内核必须有能力挂起正在CPU上执行的进程，并恢复以前挂起的某个进程的执行，这叫做进程切换、任务切换、上下文切换</p><ul><li>保存现场：顺序保存，最后一步保存PSW</li><li>选择要运行的程序</li><li>恢复现场：最后一步恢复选中进程的PSW</li></ul><h3 id="通信" tabindex="-1">通信 <a class="header-anchor" href="#通信" aria-label="Permalink to “通信”">​</a></h3><ul><li>管道:匿名/具名管道</li><li>信号量</li><li>共享内存</li><li>消息队列</li><li>套接字</li></ul><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to “线程”">​</a></h2><ul><li>将进程的两个基本属性分开，线程作为调度的基本单位，不同时作为独立分配资源的单位</li><li>线程会被频繁调度和切换</li><li>进程作为拥有资源的单位，不进行频繁切换</li></ul><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to “定义”">​</a></h3><ul><li>是进程中的一个实体，是被系统独立调度的基本单位</li></ul><h3 id="好处" tabindex="-1">好处 <a class="header-anchor" href="#好处" aria-label="Permalink to “好处”">​</a></h3><ul><li>建一个新线程花费时间少</li><li>线程的终止时间比进程短</li><li>同进程内的线程切换时间比进程短</li><li>因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li></ul><h3 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to “属性”">​</a></h3><ul><li>轻型实体:基本不拥有资源</li><li>独立调度的基本单位</li><li>可以并发执行</li><li>共享进程资源</li></ul><h3 id="线程的特征" tabindex="-1">线程的特征 <a class="header-anchor" href="#线程的特征" aria-label="Permalink to “线程的特征”">​</a></h3><ul><li>结构性 <ul><li>TCB：标识、现场信息(寄存器、PC、栈指针)、调度信息(状态、优先级)</li><li>数据块：过程参数、数据、系统与用户堆栈</li></ul></li><li>并发性 <ul><li>同一进程中的各线程在同一主存空间，可以共享进程中的所有资源（数据、设备、文件），线程间通信方便</li></ul></li><li>共享性 <ul><li>同一进程的各线程</li></ul></li><li>动态性 <ul><li>有生命周期，有状态变化，可创建子线程</li></ul></li><li>在引入线程的OS中，线程是进程中的一个实体，是被系统独立调度和分派的基本单位</li><li>线程自己基本不拥有系统资源，只拥有少量必不可少的资源：程序计数器PC、一组寄存器、栈</li><li>线程可与同属一个进程的其它线程共享进程所拥有的全部资源</li><li>一个线程可以创建和撤消另一个线程；同一进程中的多个线程之间可以并发执行</li><li>系统调度的基本单位是线程而不是进程,每当创建一个进程时，至少要同时为该进程创建一个线程，否则该进程无法被调度执行</li></ul><h3 id="线程间通信方式" tabindex="-1">线程间通信方式 <a class="header-anchor" href="#线程间通信方式" aria-label="Permalink to “线程间通信方式”">​</a></h3><ul><li>线程间的通信可以通过共享进程级全局变量</li></ul><h3 id="通信-1" tabindex="-1">通信 <a class="header-anchor" href="#通信-1" aria-label="Permalink to “通信”">​</a></h3><ul><li>共享进程级全局变量</li><li>自定义消息</li></ul><h3 id="同步方式" tabindex="-1">同步方式 <a class="header-anchor" href="#同步方式" aria-label="Permalink to “同步方式”">​</a></h3><ul><li>事件</li><li>信号量</li><li>互斥量</li><li>临界区</li></ul><h2 id="进程与线程的区别" tabindex="-1">进程与线程的区别 <a class="header-anchor" href="#进程与线程的区别" aria-label="Permalink to “进程与线程的区别”">​</a></h2><ul><li>引入进程的目的是为了使多个程序更好的并发执行，改善资源利用率、提高系统效率</li><li>引入线程则是为了减少并发执行时所付出的时空开销，使并发粒度更细、并发性更好</li></ul><h3 id="关系" tabindex="-1">关系 <a class="header-anchor" href="#关系" aria-label="Permalink to “关系”">​</a></h3><ul><li>一个线程属于一个进程</li><li>一个进程至少有一个线程</li><li>资源分配给进程,线程共享其中的资源</li><li>处理机分配给线程</li></ul><h3 id="定义-1" tabindex="-1">定义 <a class="header-anchor" href="#定义-1" aria-label="Permalink to “定义”">​</a></h3><ul><li>进程:可并发执行的程序在一个数据集合上的运行过程</li><li>线程:是进程中的一个实体，是被系统独立调度的基本单位</li></ul><h3 id="调度" tabindex="-1">调度 <a class="header-anchor" href="#调度" aria-label="Permalink to “调度”">​</a></h3><ul><li>传统OS中，拥有资源、独立调度的基本单位是进程</li><li>引入线程的系统中，线程是调度和分派的基本单位，而进程是拥有资源的基本单位</li><li>在同一个进程内线程切换不会产生进程切换，由一个进程内的线程切换到另一个进程内的线程时，将会引起进程切换</li></ul><h3 id="并发性" tabindex="-1">并发性 <a class="header-anchor" href="#并发性" aria-label="Permalink to “并发性”">​</a></h3><p>在引入线程的系统中，进程之间可并发，同一进程内的各线程之间也能并发执行。因而系统具有更好的并发性</p><h3 id="资源" tabindex="-1">资源 <a class="header-anchor" href="#资源" aria-label="Permalink to “资源”">​</a></h3><p>无论是传统OS，还是引入线程的OS，进程都是拥有资源的独立单位，线程一般不拥有系统资源，但它可以访问隶属进程的资源。即一个进程的所有资源可供进程内的所有线程共享</p><h3 id="系统开销" tabindex="-1">系统开销 <a class="header-anchor" href="#系统开销" aria-label="Permalink to “系统开销”">​</a></h3><ul><li>进程创建和撤消的开销远大于线程创建和撤消的开销 <ul><li>进程切换时，当前进程的CPU环境要保存，新进程的CPU环境要设置</li><li>线程切换时只须保存和设置少量寄存器，并不涉及存储管理方面的操作</li></ul></li><li>同一进程内的各线程由于它们拥有相同的地址空间，它们之间的同步和通信的实现也比较容易</li></ul><h3 id="目的" tabindex="-1">目的 <a class="header-anchor" href="#目的" aria-label="Permalink to “目的”">​</a></h3><ul><li>进程:为了使多个程序更好的并发执行，改善资源利用率、提高系统效率</li><li>线程:为了减少并发执行时所付出的时空开销，使并发粒度更细、并发性更好</li></ul><h3 id="差异" tabindex="-1">差异 <a class="header-anchor" href="#差异" aria-label="Permalink to “差异”">​</a></h3><h4 id="进程-1" tabindex="-1">进程 <a class="header-anchor" href="#进程-1" aria-label="Permalink to “进程”">​</a></h4><ul><li>拥有独立的地址空间:一个进程崩溃后，在保护模式下不会对其它进程产生影响</li></ul><h4 id="线程-1" tabindex="-1">线程 <a class="header-anchor" href="#线程-1" aria-label="Permalink to “线程”">​</a></h4><ul><li>只是进程中的不同执行路径</li><li>有独立的堆栈与局部变量</li><li>没有单独的地址空间</li><li>一个线程死掉等于整个进程死掉</li></ul><h4 id="小总结" tabindex="-1">小总结 <a class="header-anchor" href="#小总结" aria-label="Permalink to “小总结”">​</a></h4><ul><li>多进程程序比多线程程序健壮</li><li>进程切换时耗费资源更大,效率较差</li><li>线程执行开销小，但不利于资源的管理和保护</li><li>要求同时进行又要共享某些变量的并发操作，只能用线程，不能用进程</li><li>多个线程共享内存，从而极大地提高了程序的运行效率</li><li>进程在执行过程中拥有独立的内存单元</li></ul><h2 id="死锁" tabindex="-1">死锁 <a class="header-anchor" href="#死锁" aria-label="Permalink to “死锁”">​</a></h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行</p><h3 id="产生原因" tabindex="-1">产生原因 <a class="header-anchor" href="#产生原因" aria-label="Permalink to “产生原因”">​</a></h3><ul><li>竞争资源引起进程死锁</li><li>可剥夺和非剥夺资源</li><li>竞争非剥夺资源</li><li>竞争临时性资源</li><li>进程推进顺序不当</li></ul><h3 id="产生条件" tabindex="-1">产生条件 <a class="header-anchor" href="#产生条件" aria-label="Permalink to “产生条件”">​</a></h3><ol><li>互斥条件：涉及的资源是非共享的 <ul><li>涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放</li></ul></li><li>不剥夺条件：不能强行剥夺进程拥有的资源 <ul><li>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放</li></ul></li><li>请求和保持条件：进程在等待一新资源时继续占有已分配的资源 <ul><li>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链</li></ul></li></ol><h3 id="解决办法" tabindex="-1">解决办法 <a class="header-anchor" href="#解决办法" aria-label="Permalink to “解决办法”">​</a></h3><p>只要打破四个必要条件之一就能有效预防死锁的发生</p><h2 id="面试相关问题" tabindex="-1">面试相关问题 <a class="header-anchor" href="#面试相关问题" aria-label="Permalink to “面试相关问题”">​</a></h2><blockquote><p>能力有限,这里就没有留下个人的回答了,避免带入误区,影响到读者的总结,我相信读者可以根据上文中知识点的描述,能总结出自己的结论</p></blockquote><h3 id="_1-线程与进程的概念" tabindex="-1">1.线程与进程的概念? <a class="header-anchor" href="#_1-线程与进程的概念" aria-label="Permalink to “1.线程与进程的概念?”">​</a></h3><h3 id="_2-线程与进程的区别" tabindex="-1">2.线程与进程的区别? <a class="header-anchor" href="#_2-线程与进程的区别" aria-label="Permalink to “2.线程与进程的区别?”">​</a></h3><h3 id="_3-线程如何工作的" tabindex="-1">3.线程如何工作的? <a class="header-anchor" href="#_3-线程如何工作的" aria-label="Permalink to “3.线程如何工作的?”">​</a></h3><h3 id="_4-进程如何工作的" tabindex="-1">4.进程如何工作的? <a class="header-anchor" href="#_4-进程如何工作的" aria-label="Permalink to “4.进程如何工作的?”">​</a></h3><h3 id="_5-进程与线程是如何通信的" tabindex="-1">5.进程与线程是如何通信的? <a class="header-anchor" href="#_5-进程与线程是如何通信的" aria-label="Permalink to “5.进程与线程是如何通信的?”">​</a></h3><h3 id="_6-进程-线程之间如何进行切换的" tabindex="-1">6.进程/线程之间如何进行切换的? <a class="header-anchor" href="#_6-进程-线程之间如何进行切换的" aria-label="Permalink to “6.进程/线程之间如何进行切换的?”">​</a></h3><h3 id="_7-线程和进程的关系" tabindex="-1">7.线程和进程的关系? <a class="header-anchor" href="#_7-线程和进程的关系" aria-label="Permalink to “7.线程和进程的关系?”">​</a></h3><h3 id="_8-什么是死锁-为什么会出现-如何避免" tabindex="-1">8.什么是死锁?为什么会出现?如何避免? <a class="header-anchor" href="#_8-什么是死锁-为什么会出现-如何避免" aria-label="Permalink to “8.什么是死锁?为什么会出现?如何避免?”">​</a></h3>',82)])])}const m=a(h,[["render",n]]);export{b as __pageData,m as default};
